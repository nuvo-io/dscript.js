// Generated by CoffeeScript 1.6.3
/*
  jshapes is a web implementation of the "shapes" application used
   by DDS vendors to demonstrate interoperability.  That said this
   simple application tries to show how DDS can be effectively used to
   stream and render real-time data in a web-browser.

   For information contact angelo@icorsaro.net
*/


(function() {
  var JShapesProperties, Shape, ShapeColor, animate, bindShape, bouncingCircles, bouncingDynamic, bouncingSquares, bouncingTriangles, circleBBox, circleDR, circleDW, circleTopic, clearCircles, clearPS, clearSquares, clearTopicPubSub, clearTriangles, colorMap, connect, disconnect, drawCircle, drawSquare, drawTriangle, drawTriangleShape, drqos, dscriptServer, dwqos, exports, inCircleCache, inSquareCache, inTriangleCache, jshapes, outCircleCache, outSquareCache, outTriangleCache, publishTopic, randomShape, root, runJShapes, runtime, squareBBox, squareDR, squareDW, squareTopic, stripShape, subscribeTopic, triangleBBox, triangleDR, triangleDW, triangleTopic,
    _this = this;

  root = this;

  jshapes = {};

  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = jshapes;
    }
    exports.jshapes = jshapes;
  } else {
    root.jshapes = jshapes;
  }

  dscriptServer = 'ws://10.100.1.247:9000';

  runtime = new dds.Runtime(dscriptServer);

  runtime.ondisconnect = function(e) {
    var pb, sb;
    sb = root.document.getElementById("subscribeBtn");
    console.log("Enabling " + sb);
    sb.disabled = true;
    pb = root.document.getElementById("publishBtn");
    pb.disabled = true;
    return alert('Connection Failure! Please check your Internet connection');
  };

  runtime.onconnect = function() {
    var cb, clrb, pb, sb;
    sb = root.document.getElementById("subscribeBtn");
    sb.disabled = false;
    pb = root.document.getElementById("publishBtn");
    pb.disabled = false;
    cb = root.document.getElementById("connectBtn");
    cb.innerHTML = " Disconnect";
    cb.onclick = disconnect;
    clrb = root.document.getElementById("clearTPSBtn");
    return clrb.disabled = false;
  };

  runtime.ondisconnect = function() {
    var cb;
    cb = root.document.getElementById("connectBtn");
    cb.innerHTML = " Connect";
    return cb.onclick = connect;
  };

  connect = function() {
    return runtime.connect(dsconf.dscriptServer);
  };

  disconnect = function() {
    return runtime.disconnect();
  };

  clearTopicPubSub = function() {
    var sub;
    sub = JShapesProperties.shapeTopic();
    switch (sub) {
      case "Circle":
        return clearCircles();
      case "Square":
        return clearSquares();
      case "Triangle":
        return clearTriangles();
    }
  };

  JShapesProperties = {
    logo: {
      img: new Image(),
      coord: {
        x: 280,
        y: 300
      }
    },
    bounds: {
      w: 501,
      h: 361
    },
    refresh: 40,
    canvas: function() {
      return root.document.getElementById("iShapeCanvas");
    },
    g2d: function() {
      return root.document.getElementById("iShapeCanvas").getContext("2d");
    },
    shapeTopic: function() {
      return root.document.getElementById("topicSelection").value.toString();
    },
    shapeColor: function() {
      return root.document.getElementById("colorSelection").value.toString();
    },
    shapeSize: function() {
      return parseInt(root.document.getElementById("topicSize").value.toString(), 10);
    },
    shapeSpeedX: function() {
      return parseInt(root.document.getElementById("topicSpeedX").value.toString(), 10);
    },
    shapeSpeedY: function() {
      return parseInt(root.document.getElementById("topicSpeedY").value.toString(), 10);
    },
    shapeHistory: function() {
      return parseInt(root.document.getElementById("historyDepth").value, 10);
    },
    shapeHistoryPolicy: function() {
      return dds.History.KeepLast(parseInt(root.document.getElementById("historyDepth").value, 10));
    },
    shapePartitionPolicy: function() {
      return dds.Partition(root.document.getElementById("partition").value);
    },
    shapeReliabilityPolicy: function() {
      var kind;
      kind = parseInt(root.document.getElementById("reliability").value.toString(), 10);
      if (kind === dds.ReliabilityKind.BestEffort) {
        return dds.Reliability.BestEffort;
      } else {
        return dds.Reliability.Reliable;
      }
    },
    shapeTimeFilter: function() {
      var tfv;
      tfv = parseInt(root.document.getElementById("tfilter").value, 10);
      console.log("TimeFilter = " + tfv);
      if (tfv === 0) {
        return dds.None;
      } else {
        return new dds.Some(dds.TimeFilter(tfv));
      }
    },
    shapeContentFilter: function() {
      var fv;
      fv = root.document.getElementById("cfilter").value;
      console.log("CFilter = " + fv);
      if (fv.length === 0) {
        return dds.None;
      } else {
        return new dds.Some(dds.ContentFilter(fv));
      }
    },
    shapeReaderQos: function() {
      var baseqos, cfp, tfp;
      baseqos = new dds.DataReaderQos(JShapesProperties.shapeReliabilityPolicy(), JShapesProperties.shapePartitionPolicy(), JShapesProperties.shapeHistoryPolicy());
      cfp = JShapesProperties.shapeContentFilter();
      tfp = JShapesProperties.shapeTimeFilter();
      baseqos = cfp !== dds.None ? baseqos.add(cfp.get()) : baseqos;
      if (tfp !== dds.None) {
        return baseqos.add(tfp.get());
      } else {
        return baseqos;
      }
    },
    shapeWriterQos: function() {
      return new dds.DataWriterQos(JShapesProperties.shapeReliabilityPolicy(), JShapesProperties.shapePartitionPolicy(), JShapesProperties.shapeHistoryPolicy());
    },
    defaultShapeSize: 60
  };

  JShapesProperties.logo.img.src = "./images/logo.png";

  ShapeColor = {
    red: "RED",
    green: "GREEN",
    blue: "BLUE",
    orange: "ORANGE",
    yellow: "YELLOW",
    magenta: "MAGENTA",
    cyan: "CYAN",
    gray: "GRAY",
    white: "WHITE",
    black: "BLACK"
  };

  colorMap = {};

  colorMap[ShapeColor.red] = "#cc3333";

  colorMap[ShapeColor.green] = "#99cc66";

  colorMap[ShapeColor.blue] = "#336699";

  colorMap[ShapeColor.orange] = "#ff9933";

  colorMap[ShapeColor.yellow] = "#ffff66";

  colorMap[ShapeColor.magenta] = "#cc99cc";

  colorMap[ShapeColor.cyan] = "#99ccff";

  colorMap[ShapeColor.gray] = "#666666";

  colorMap[ShapeColor.white] = "#ffffff";

  colorMap[ShapeColor.black] = "#000000";

  drqos = new dds.DataReaderQos(dds.Reliability.Reliable);

  dwqos = new dds.DataWriterQos(dds.Reliability.BestEffort);

  circleTopic = new dds.Topic(0, 'Circle', 'org.omg.dds.demo.ShapeType');

  squareTopic = new dds.Topic(0, 'Square', 'org.omg.dds.demo.ShapeType');

  triangleTopic = new dds.Topic(0, 'Triangle', 'org.omg.dds.demo.ShapeType');

  circleDR = null;

  squareDR = null;

  triangleDR = null;

  circleDW = null;

  squareDW = null;

  triangleDW = null;

  inCircleCache = dds.None;

  inSquareCache = dds.None;

  inTriangleCache = dds.None;

  outCircleCache = dds.None;

  outSquareCache = dds.None;

  outTriangleCache = dds.None;

  bindShape = dds.bind(function(s) {
    return s.color;
  });

  Shape = (function() {
    function Shape(color, shapesize, x, y, dx, dy) {
      this.color = color;
      this.shapesize = shapesize;
      this.x = x;
      this.y = y;
      this.dx = dx;
      this.dy = dy;
    }

    return Shape;

  })();

  randomShape = function(color, size, dx, dy) {
    var s;
    s = new Shape();
    s.color = color;
    s.shapesize = size;
    s.x = Math.floor(Math.random() * JShapesProperties.bounds.w);
    s.y = Math.floor(Math.random() * JShapesProperties.bounds.h);
    s.dx = dx;
    s.dy = dy;
    return s;
  };

  stripShape = function(s) {
    var ss;
    ss = {};
    ss.color = s.color;
    ss.x = s.x;
    ss.y = s.y;
    ss.shapesize = s.shapesize;
    return ss;
  };

  drawCircle = function(g2d, dotcolor) {
    return function(s) {
      g2d.fillStyle = colorMap[s.color];
      g2d.beginPath();
      g2d.arc(s.x, s.y, s.shapesize / 2, 0, 2 * Math.PI, true);
      g2d.fill();
      g2d.fillStyle = dotcolor;
      g2d.beginPath();
      g2d.arc(s.x, s.y, s.shapesize / 6, 0, 2 * Math.PI, true);
      g2d.closePath();
      return g2d.fill();
    };
  };

  drawSquare = function(g2d, dotcolor) {
    return function(s) {
      var scaledw, x0, y0;
      g2d.fillStyle = colorMap[s.color];
      g2d.fillRect(s.x, s.y, s.shapesize, s.shapesize);
      g2d.fillStyle = dotcolor;
      scaledw = s.shapesize / 3;
      x0 = s.x + scaledw;
      y0 = s.y + scaledw;
      return g2d.fillRect(x0, y0, scaledw, scaledw);
    };
  };

  drawTriangleShape = function(g2d, a, m) {
    g2d.beginPath();
    g2d.moveTo(0, 0);
    g2d.lineTo(a, 0);
    g2d.lineTo(a - m, -a);
    return g2d.closePath();
  };

  drawTriangle = function(g2d, dotcolor) {
    return function(s) {
      var a, m, x0, y0;
      g2d.save();
      x0 = s.x;
      y0 = s.y + s.shapesize;
      g2d.translate(x0, y0);
      g2d.fillStyle = colorMap[s.color];
      a = s.shapesize;
      m = s.shapesize / 2;
      drawTriangleShape(g2d, a, m);
      g2d.fill();
      g2d.restore();
      g2d.save();
      x0 = s.x + m;
      y0 = s.y + 1.25 * m;
      g2d.fillStyle = dotcolor;
      g2d.beginPath();
      g2d.arc(x0, y0, s.shapesize / 6, 0, 2 * Math.PI, true);
      g2d.closePath();
      g2d.fill();
      return g2d.restore();
    };
  };

  /*
     Bounding box for different shapes
  */


  circleBBox = function(s) {
    var bbox, r;
    r = s.shapesize / 2;
    bbox = {};
    bbox.x = s.x - r;
    bbox.y = s.y - r;
    bbox.w = bbox.h = s.shapesize;
    return bbox;
  };

  squareBBox = function(s) {
    var bbox;
    bbox = {};
    bbox.x = s.x;
    bbox.y = s.y;
    bbox.w = bbox.h = s.shapesize;
    return bbox;
  };

  triangleBBox = squareBBox;

  /*
    Dynamics
      bbox -> gives the bounding for the given shape
      bounds -> the bounds within which the shape has to bounce
      dx, dy -> speed in x, y direction
  */


  bouncingDynamic = function(bbox, bounds) {
    return function(s) {
      var box, dx, dy, x, y;
      box = bbox(s);
      dx = s.dx;
      dy = s.dy;
      if (box.x + box.w > bounds.w) {
        if (dx > 0) {
          dx = -dx;
        }
        if (Math.random() > 0.5) {
          dy = -dy;
        }
        x = bounds.w - box.w;
      } else if (box.y + box.h > bounds.h) {
        if (dy > 0) {
          dy = -dy;
        }
        if (Math.random() > 0.5) {
          dx = -dx;
        }
        y = bounds.h - box.h;
      } else if (box.x <= 0) {
        if (dx < 0) {
          dx = -dx;
        }
        if (Math.random() > 0.5) {
          dy = -dy;
        }
      } else if (box.y <= 0) {
        if (dy < 0) {
          dy = -dy;
        }
        if (Math.random() > 0.5) {
          dx = -dx;
        }
      }
      s.x = s.x + dx;
      s.y = s.y + dy;
      s.dx = dx;
      s.dy = dy;
      return s;
    };
  };

  bouncingCircles = bouncingDynamic(circleBBox, JShapesProperties.bounds);

  bouncingSquares = bouncingDynamic(squareBBox, JShapesProperties.bounds);

  bouncingTriangles = bouncingDynamic(triangleBBox, JShapesProperties.bounds);

  animate = function() {
    var blackSpotCirlce, blackSpotSquare, blackSpotTriangle, g2d, whiteSpotCircle, whiteSpotSquare, whiteSpotTriangle;
    g2d = JShapesProperties.g2d();
    g2d.fillStyle = colorMap[ShapeColor.white];
    g2d.fillRect(0, 0, JShapesProperties.bounds.w, JShapesProperties.bounds.h);
    g2d.drawImage(JShapesProperties.logo.img, JShapesProperties.logo.coord.x, JShapesProperties.logo.coord.y);
    whiteSpotCircle = drawCircle(g2d, colorMap[ShapeColor.white]);
    blackSpotCirlce = drawCircle(g2d, colorMap[ShapeColor.black]);
    whiteSpotSquare = drawSquare(g2d, colorMap[ShapeColor.white]);
    blackSpotSquare = drawSquare(g2d, colorMap[ShapeColor.black]);
    whiteSpotTriangle = drawTriangle(g2d, colorMap[ShapeColor.white]);
    blackSpotTriangle = drawTriangle(g2d, colorMap[ShapeColor.black]);
    outCircleCache.map(function(c) {
      return c.forEach(whiteSpotCircle);
    });
    outSquareCache.map(function(c) {
      return c.forEach(whiteSpotSquare);
    });
    outTriangleCache.map(function(c) {
      return c.forEach(whiteSpotTriangle);
    });
    inCircleCache.map(function(c) {
      return c.forEach(blackSpotCirlce);
    });
    inSquareCache.map(function(c) {
      return c.forEach(blackSpotSquare);
    });
    inTriangleCache.map(function(c) {
      return c.forEach(blackSpotTriangle);
    });
    outCircleCache = outCircleCache.map(function(c) {
      return c.map(bouncingCircles);
    });
    outSquareCache = outSquareCache.map(function(c) {
      return c.map(bouncingSquares);
    });
    outTriangleCache = outTriangleCache.map(function(c) {
      return c.map(bouncingTriangles);
    });
    outCircleCache.map(function(c) {
      return c.forEach(function(s) {
        return circleDW.write(stripShape(s));
      });
    });
    outSquareCache.map(function(c) {
      return c.forEach(function(s) {
        return squareDW.write(stripShape(s));
      });
    });
    return outTriangleCache.map(function(c) {
      return c.forEach(function(s) {
        return triangleDW.write(stripShape(s));
      });
    });
  };

  publishTopic = function() {
    var color, dwQos, dx, dy, shape, size, ts;
    ts = JShapesProperties.shapeTopic();
    color = JShapesProperties.shapeColor();
    size = 2 * JShapesProperties.shapeSize();
    dx = JShapesProperties.shapeSpeedX();
    dy = JShapesProperties.shapeSpeedY();
    shape = randomShape(color, size, dx, dy);
    dwQos = JShapesProperties.shapeWriterQos();
    if (ts === 'Circle') {
      if (circleDW === null) {
        circleDW = new dds.DataWriter(runtime, circleTopic, dwQos);
        outCircleCache = new dds.Some(new dds.DataCache(1));
      }
      return outCircleCache.map(function(c) {
        return c.write(color, shape);
      });
    } else if (ts === 'Square') {
      if (squareDW === null) {
        squareDW = new dds.DataWriter(runtime, squareTopic, dwQos);
        outSquareCache = new dds.Some(new dds.DataCache(1));
      }
      return outSquareCache.map(function(c) {
        return c.write(color, shape);
      });
    } else if (ts === "Triangle") {
      if (triangleDW === null) {
        triangleDW = new dds.DataWriter(runtime, triangleTopic, dwQos);
        outTriangleCache = new dds.Some(new dds.DataCache(1));
      }
      return outTriangleCache.map(function(c) {
        return c.write(color, shape);
      });
    }
  };

  subscribeTopic = function() {
    var drQos, history, ts;
    ts = JShapesProperties.shapeTopic();
    drQos = JShapesProperties.shapeReaderQos();
    history = JShapesProperties.shapeHistory();
    if (ts === "Circle" && circleDR === null) {
      circleDR = new dds.DataReader(runtime, circleTopic, drQos);
      inCircleCache = new dds.Some(new dds.DataCache(history));
      return inCircleCache.map(function(c) {
        return bindShape(circleDR, c);
      });
    } else if (ts === "Square" && squareDR === null) {
      squareDR = new dds.DataReader(runtime, squareTopic, drQos);
      inSquareCache = new dds.Some(new dds.DataCache(history));
      return inSquareCache.map(function(c) {
        return bindShape(squareDR, c);
      });
    } else if (ts === "Triangle" && triangleDR === null) {
      triangleDR = new dds.DataReader(runtime, triangleTopic, drQos);
      inTriangleCache = new dds.Some(new dds.DataCache(history));
      return inTriangleCache.map(function(c) {
        return bindShape(triangleDR, c);
      });
    }
  };

  runJShapes = function() {
    return setInterval("animate()", JShapesProperties.refresh);
  };

  clearPS = function(r, rc, w, wc) {
    if (r !== null) {
      r.close();
    }
    if (w !== null) {
      w.close();
    }
    rc = dds.None;
    return wc = dds.None;
  };

  clearCircles = function() {
    clearPS(circleDR, inCircleCache, circleDW, outCircleCache);
    circleDR = circleDW = null;
    return inCircleCache = outCircleCache = dds.None;
  };

  clearSquares = function() {
    clearPS(squareDR, inSquareCache, squareDW, outSquareCache);
    squareDR = squareDW = null;
    return inSquareCache = outSquareCache = dds.None;
  };

  clearTriangles = function() {
    clearPS(triangleDR, inTriangleCache, squareDW, outTriangleCache);
    triangleDR = triangleDW = null;
    return inTriangleCache = outTriangleCache = dds.None;
  };

  this.animate = animate;

  this.runJShapes = runJShapes;

  this.publishTopic = publishTopic;

  this.subscribeTopic = subscribeTopic;

  this.connect = connect;

  this.disconnect = disconnect;

  this.clearTopicPubSub = clearTopicPubSub;

  this.window.onload = function() {
    return runJShapes();
  };

}).call(this);

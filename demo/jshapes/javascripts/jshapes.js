// Generated by CoffeeScript 1.6.3
/*
   jshapes is a web implementation of the "shapes" application used by DDS vendors to demonstrate interoperability.
   That said this simple application tries to show how DDS can be effectively used to stream and render
   real-time data in a web-browser.

   For information contact angelo@icorsaro.net
*/


(function() {
  var JShapesProperties, Shape, ShapeColor, animate, bindShape, bouncingCircles, bouncingDynamic, bouncingSquares, bouncingTriangles, circleBBox, circleDR, circleDW, circleTopic, colorMap, drawCircle, drawSquare, drawTriangle, drawTriangleShape, drqos, dwqos, exports, inCircleCache, inSquareCache, inTriangleCache, jshapes, outCircleCache, outSquareCache, outTriangleCache, publishTopic, randomShape, root, runJShapes, squareBBox, squareDR, squareDW, squareTopic, stripShape, subscribeTopic, triangleBBox, triangleDR, triangleDW, triangleTopic,
    _this = this;

  root = this;

  jshapes = {};

  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = jshapes;
    }
    exports.jshapes = jshapes;
  } else {
    root.jshapes = jshapes;
  }

  dds.VERSION = "0.1.0";

  JShapesProperties = {
    logo: {
      img: new Image(),
      coord: {
        x: 280,
        y: 300
      }
    },
    bounds: {
      w: 501,
      h: 361
    },
    refresh: 40,
    canvas: function() {
      return root.document.getElementById("iShapeCanvas");
    },
    g2d: function() {
      return root.document.getElementById("iShapeCanvas").getContext("2d");
    },
    shapeTopic: function() {
      return root.document.getElementById("topicSelection").value.toString();
    },
    shapeColor: function() {
      return root.document.getElementById("colorSelection").value.toString();
    },
    shapeSize: function() {
      return parseInt(root.document.getElementById("topicSize").value.toString(), 10);
    },
    shapeSpeedX: function() {
      return parseInt(root.document.getElementById("topicSpeedX").value.toString(), 10);
    },
    shapeSpeedY: function() {
      return parseInt(root.document.getElementById("topicSpeedY").value.toString(), 10);
    },
    shapeHistory: function() {
      return parseInt(root.document.getElementById("historyDepth").value, 10);
    },
    shapeHistoryPolicy: function() {
      return dds.History.KeepLast(parseInt(root.document.getElementById("historyDepth").value, 10));
    },
    shapePartitionPolicy: function() {
      return dds.Partition(root.document.getElementById("partition").value);
    },
    shapeReliabilityPolicy: function() {
      var kind;
      kind = parseInt(root.document.getElementById("reliability").value.toString(), 10);
      if (kind === dds.ReliabilityKind.BestEffort) {
        return dds.Reliability.BestEffort;
      } else {
        return dds.Reliability.Reliable;
      }
    },
    shapeTimeFilter: function() {
      var tfv;
      tfv = parseInt(root.document.getElementById("tfilter").value, 10);
      console.log("TimeFilter = " + tfv);
      if (tfv === 0) {
        return dds.None;
      } else {
        return new dds.Some(dds.TimeFilter(tfv));
      }
    },
    shapeContentFilter: function() {
      var fv;
      fv = root.document.getElementById("cfilter").value;
      console.log("CFilter = " + fv);
      if (fv.length === 0) {
        return dds.None;
      } else {
        return new dds.Some(dds.ContentFilter(fv));
      }
    },
    shapeReaderQos: function() {
      var baseqos, cfp, tfp;
      baseqos = new dds.DataReaderQos(JShapesProperties.shapeReliabilityPolicy(), JShapesProperties.shapePartitionPolicy(), JShapesProperties.shapeHistoryPolicy());
      cfp = JShapesProperties.shapeContentFilter();
      tfp = JShapesProperties.shapeTimeFilter();
      baseqos = cfp !== dds.None ? baseqos.add(cfp.get()) : baseqos;
      if (tfp !== dds.None) {
        return baseqos.add(tfp.get());
      } else {
        return baseqos;
      }
    },
    shapeWriterQos: function() {
      return new dds.DataWriterQos(JShapesProperties.shapeReliabilityPolicy(), JShapesProperties.shapePartitionPolicy(), JShapesProperties.shapeHistoryPolicy());
    },
    defaultShapeSize: 60
  };

  JShapesProperties.logo.img.src = "./images/logo.png";

  ShapeColor = {
    red: "RED",
    green: "GREEN",
    blue: "BLUE",
    orange: "ORANGE",
    yellow: "YELLOW",
    magenta: "MAGENTA",
    cyan: "CYAN",
    gray: "GRAY",
    white: "WHITE",
    black: "BLACK"
  };

  colorMap = {};

  colorMap[ShapeColor.red] = "#cc3333";

  colorMap[ShapeColor.green] = "#99cc66";

  colorMap[ShapeColor.blue] = "#336699";

  colorMap[ShapeColor.orange] = "#ff9933";

  colorMap[ShapeColor.yellow] = "#ffff66";

  colorMap[ShapeColor.magenta] = "#cc99cc";

  colorMap[ShapeColor.cyan] = "#99ccff";

  colorMap[ShapeColor.gray] = "#666666";

  colorMap[ShapeColor.white] = "#ffffff";

  colorMap[ShapeColor.black] = "#000000";

  drqos = new dds.DataReaderQos(dds.Reliability.Reliable);

  dwqos = new dds.DataWriterQos(dds.Reliability.BestEffort);

  circleTopic = new dds.Topic(0, 'Circle', 'org.omg.dds.demo.ShapeType');

  squareTopic = new dds.Topic(0, 'Square', 'org.omg.dds.demo.ShapeType');

  triangleTopic = new dds.Topic(0, 'Triangle', 'org.omg.dds.demo.ShapeType');

  circleDR = null;

  squareDR = null;

  triangleDR = null;

  circleDW = null;

  squareDW = null;

  triangleDW = null;

  inCircleCache = dds.None;

  inSquareCache = dds.None;

  inTriangleCache = dds.None;

  outCircleCache = dds.None;

  outSquareCache = dds.None;

  outTriangleCache = dds.None;

  bindShape = dds.bind(function(s) {
    return s.color;
  });

  Shape = (function() {
    function Shape(color, shapesize, x, y, dx, dy) {
      this.color = color;
      this.shapesize = shapesize;
      this.x = x;
      this.y = y;
      this.dx = dx;
      this.dy = dy;
    }

    return Shape;

  })();

  randomShape = function(color, size, dx, dy) {
    var s;
    s = new Shape();
    s.color = color;
    s.shapesize = size;
    s.x = Math.floor(Math.random() * JShapesProperties.bounds.w);
    s.y = Math.floor(Math.random() * JShapesProperties.bounds.h);
    s.dx = dx;
    s.dy = dy;
    return s;
  };

  stripShape = function(s) {
    var ss;
    ss = {};
    ss.color = s.color;
    ss.x = s.x;
    ss.y = s.y;
    ss.shapesize = s.shapesize;
    return ss;
  };

  drawCircle = function(g2d, dotcolor) {
    return function(s) {
      g2d.fillStyle = colorMap[s.color];
      g2d.beginPath();
      g2d.arc(s.x, s.y, s.shapesize / 2, 0, 2 * Math.PI, true);
      g2d.fill();
      g2d.fillStyle = dotcolor;
      g2d.beginPath();
      g2d.arc(s.x, s.y, s.shapesize / 6, 0, 2 * Math.PI, true);
      g2d.closePath();
      return g2d.fill();
    };
  };

  drawSquare = function(g2d, dotcolor) {
    return function(s) {
      var scaledw, x0, y0;
      g2d.fillStyle = colorMap[s.color];
      g2d.fillRect(s.x, s.y, s.shapesize, s.shapesize);
      g2d.fillStyle = dotcolor;
      scaledw = s.shapesize / 3;
      x0 = s.x + scaledw;
      y0 = s.y + scaledw;
      return g2d.fillRect(x0, y0, scaledw, scaledw);
    };
  };

  drawTriangleShape = function(g2d, a, m) {
    g2d.beginPath();
    g2d.moveTo(0, 0);
    g2d.lineTo(a, 0);
    g2d.lineTo(a - m, -a);
    return g2d.closePath();
  };

  drawTriangle = function(g2d, dotcolor) {
    return function(s) {
      var a, m, x0, y0;
      g2d.save();
      x0 = s.x;
      y0 = s.y + s.shapesize;
      g2d.translate(x0, y0);
      g2d.fillStyle = colorMap[s.color];
      a = s.shapesize;
      m = s.shapesize / 2;
      drawTriangleShape(g2d, a, m);
      g2d.fill();
      g2d.restore();
      g2d.save();
      x0 = s.x + m;
      y0 = s.y + 1.25 * m;
      g2d.fillStyle = dotcolor;
      g2d.beginPath();
      g2d.arc(x0, y0, s.shapesize / 6, 0, 2 * Math.PI, true);
      g2d.closePath();
      g2d.fill();
      return g2d.restore();
    };
  };

  /*
     Bounding box for different shapes
  */


  circleBBox = function(s) {
    var bbox, r;
    r = s.shapesize / 2;
    bbox = {};
    bbox.x = s.x - r;
    bbox.y = s.y - r;
    bbox.w = bbox.h = s.shapesize;
    return bbox;
  };

  squareBBox = function(s) {
    var bbox;
    bbox = {};
    bbox.x = s.x;
    bbox.y = s.y;
    bbox.w = bbox.h = s.shapesize;
    return bbox;
  };

  triangleBBox = squareBBox;

  /*
    Dynamics
      bbox -> gives the bounding for the given shape
      bounds -> the bounds within which the shape has to bounce
      dx, dy -> speed in x, y direction
  */


  bouncingDynamic = function(bbox, bounds) {
    return function(s) {
      var box, dx, dy, x, y;
      box = bbox(s);
      dx = s.dx;
      dy = s.dy;
      if (box.x + box.w > bounds.w) {
        if (dx > 0) {
          dx = -dx;
        }
        if (Math.random() > 0.5) {
          dy = -dy;
        }
        x = bounds.w - box.w;
      } else if (box.y + box.h > bounds.h) {
        if (dy > 0) {
          dy = -dy;
        }
        if (Math.random() > 0.5) {
          dx = -dx;
        }
        y = bounds.h - box.h;
      } else if (box.x <= 0) {
        if (dx < 0) {
          dx = -dx;
        }
        if (Math.random() > 0.5) {
          dy = -dy;
        }
      } else if (box.y <= 0) {
        if (dy < 0) {
          dy = -dy;
        }
        if (Math.random() > 0.5) {
          dx = -dx;
        }
      }
      s.x = s.x + dx;
      s.y = s.y + dy;
      s.dx = dx;
      s.dy = dy;
      return s;
    };
  };

  bouncingCircles = bouncingDynamic(circleBBox, JShapesProperties.bounds);

  bouncingSquares = bouncingDynamic(squareBBox, JShapesProperties.bounds);

  bouncingTriangles = bouncingDynamic(triangleBBox, JShapesProperties.bounds);

  animate = function() {
    var blackSpotCirlce, blackSpotSquare, blackSpotTriangle, g2d, whiteSpotCircle, whiteSpotSquare, whiteSpotTriangle;
    g2d = JShapesProperties.g2d();
    g2d.fillStyle = colorMap[ShapeColor.white];
    g2d.fillRect(0, 0, JShapesProperties.bounds.w, JShapesProperties.bounds.h);
    g2d.drawImage(JShapesProperties.logo.img, JShapesProperties.logo.coord.x, JShapesProperties.logo.coord.y);
    whiteSpotCircle = drawCircle(g2d, colorMap[ShapeColor.white]);
    blackSpotCirlce = drawCircle(g2d, colorMap[ShapeColor.black]);
    whiteSpotSquare = drawSquare(g2d, colorMap[ShapeColor.white]);
    blackSpotSquare = drawSquare(g2d, colorMap[ShapeColor.black]);
    whiteSpotTriangle = drawTriangle(g2d, colorMap[ShapeColor.white]);
    blackSpotTriangle = drawTriangle(g2d, colorMap[ShapeColor.black]);
    outCircleCache.map(function(c) {
      return c.forEach(whiteSpotCircle);
    });
    outSquareCache.map(function(c) {
      return c.forEach(whiteSpotSquare);
    });
    outTriangleCache.map(function(c) {
      return c.forEach(whiteSpotTriangle);
    });
    inCircleCache.map(function(c) {
      return c.forEach(blackSpotCirlce);
    });
    inSquareCache.map(function(c) {
      return c.forEach(blackSpotSquare);
    });
    inTriangleCache.map(function(c) {
      return c.forEach(blackSpotTriangle);
    });
    outCircleCache = outCircleCache.map(function(c) {
      return c.map(bouncingCircles);
    });
    outSquareCache = outSquareCache.map(function(c) {
      return c.map(bouncingSquares);
    });
    outTriangleCache = outTriangleCache.map(function(c) {
      return c.map(bouncingTriangles);
    });
    outCircleCache.map(function(c) {
      return c.forEach(function(s) {
        return circleDW.write(stripShape(s));
      });
    });
    outSquareCache.map(function(c) {
      return c.forEach(function(s) {
        return squareDW.write(stripShape(s));
      });
    });
    return outTriangleCache.map(function(c) {
      return c.forEach(function(s) {
        return triangleDW.write(stripShape(s));
      });
    });
  };

  publishTopic = function() {
    var color, dwQos, dx, dy, shape, size, ts;
    ts = JShapesProperties.shapeTopic();
    color = JShapesProperties.shapeColor();
    size = 2 * JShapesProperties.shapeSize();
    dx = JShapesProperties.shapeSpeedX();
    dy = JShapesProperties.shapeSpeedY();
    shape = randomShape(color, size, dx, dy);
    dwQos = JShapesProperties.shapeWriterQos();
    if (ts === 'Circle') {
      if (circleDW === null) {
        circleDW = new dds.DataWriter(circleTopic, dwQos);
        outCircleCache = new dds.Some(new dds.DataCache(1));
      }
      return outCircleCache.map(function(c) {
        return c.write(color, shape);
      });
    } else if (ts === 'Square') {
      if (squareDW === null) {
        squareDW = new dds.DataWriter(squareTopic, dwQos);
        outSquareCache = new dds.Some(new dds.DataCache(1));
      }
      return outSquareCache.map(function(c) {
        return c.write(color, shape);
      });
    } else if (ts === "Triangle") {
      if (triangleDW === null) {
        triangleDW = new dds.DataWriter(triangleTopic, dwQos);
        outTriangleCache = new dds.Some(new dds.DataCache(1));
      }
      return outTriangleCache.map(function(c) {
        return c.write(color, shape);
      });
    }
  };

  subscribeTopic = function() {
    var drQos, history, ts;
    ts = JShapesProperties.shapeTopic();
    drQos = JShapesProperties.shapeReaderQos();
    history = JShapesProperties.shapeHistory();
    if (ts === "Circle" && circleDR === null) {
      circleDR = new dds.DataReader(circleTopic, drQos);
      inCircleCache = new dds.Some(new dds.DataCache(history));
      return inCircleCache.map(function(c) {
        return bindShape(circleDR, c);
      });
    } else if (ts === "Square" && squareDR === null) {
      squareDR = new dds.DataReader(squareTopic, drQos);
      inSquareCache = new dds.Some(new dds.DataCache(history));
      return inSquareCache.map(function(c) {
        return bindShape(squareDR, c);
      });
    } else if (ts === "Triangle" && triangleDR === null) {
      triangleDR = new dds.DataReader(triangleTopic, drQos);
      inTriangleCache = new dds.Some(new dds.DataCache(history));
      return inTriangleCache.map(function(c) {
        return bindShape(triangleDR, c);
      });
    }
  };

  runJShapes = function() {
    return setInterval("animate()", JShapesProperties.refresh);
  };

  this.animate = animate;

  this.runJShapes = runJShapes;

  this.publishTopic = publishTopic;

  this.subscribeTopic = subscribeTopic;

  this.window.onload = function() {
    return runJShapes();
  };

}).call(this);

// Generated by CoffeeScript 1.6.3
(function() {
  var ContentFilter, DSCommandId, DSEntityKind, DataCache, DataReader, DataWriter, Durability, DurabilityKind, EntityQos, Failure, History, HistoryKind, None, Partition, PolicyId, Reliability, ReliabilityKind, Runtime, Some, Success, TimeFilter, Topic, controllerPath, controllerURL, createCommand, createHeader, createTopicInfo, dds, exports, readerPrefixPath, readerPrefixURL, root, writerPrefixPath, writerPrefixURL,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __slice = [].slice;

  root = this;

  dds = {};

  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = dds;
    }
    exports.dds = dds;
  } else {
    root.dds = dds;
  }

  dds.VERSION = "0.1.0";

  None = {};

  None.map = function(f) {
    return None;
  };

  None.flatMap = function(f) {
    return None;
  };

  None.get = function() {
    return void 0;
  };

  None.getOrElse = function(f) {
    return f();
  };

  None.orElse = function(f) {
    return f();
  };

  None.isEmpty = function() {
    return true;
  };

  Some = (function() {
    function Some(value) {
      this.value = value;
    }

    Some.prototype.map = function(f) {
      return new Some(f(this.value));
    };

    Some.prototype.flatMap = function(f) {
      return f(this.value);
    };

    Some.prototype.get = function() {
      return this.value;
    };

    Some.prototype.getOrElse = function(f) {
      return this.value;
    };

    Some.prototype.orElse = function(f) {
      return this;
    };

    Some.prototype.isEmpty = function() {
      return false;
    };

    return Some;

  })();

  Success = (function() {
    function Success(value) {
      this.value = value;
    }

    Success.prototype.map = function(f) {
      return f(this.value);
    };

    Success.prototype.get = function() {
      return this.value;
    };

    Success.prototype.getOrElse = function(f) {
      return this.value;
    };

    Success.prototype.orElse = function(f) {
      return this;
    };

    Success.prototype.isFailure = function() {
      return false;
    };

    Success.prototype.isSuccess = function() {
      return true;
    };

    Success.prototype.toOption = function() {
      return new Some(this.value);
    };

    Success.prototype.recover = function(f) {
      return this;
    };

    return Success;

  })();

  Failure = (function() {
    function Failure(exception) {
      this.exception = exception;
    }

    Failure.prototype.map = function(f) {
      return None;
    };

    Failure.prototype.get = function() {
      return this.exception;
    };

    Failure.prototype.getOrElse = function(f) {
      return f();
    };

    Failure.prototype.orElse = function(f) {
      return f();
    };

    Failure.prototype.isFailure = function() {
      return true;
    };

    Failure.prototype.isSuccess = function() {
      return false;
    };

    Failure.prototype.toOption = function() {
      return None;
    };

    Failure.prototype.recover = function(f) {
      return f(this.exception);
    };

    return Failure;

  })();

  Topic = (function() {
    function Topic(did, tname, ttype) {
      this.did = did;
      this.tname = tname;
      this.ttype = ttype;
    }

    return Topic;

  })();

  DataReader = (function() {
    function DataReader(runtime, topic, qos) {
      this.runtime = runtime;
      this.topic = topic;
      this.qos = qos;
      this.isClosed = __bind(this.isClosed, this);
      this.close = __bind(this.close, this);
      this.socketCloseHandler = __bind(this.socketCloseHandler, this);
      this.onDataAvailable = __bind(this.onDataAvailable, this);
      this.removeListener = __bind(this.removeListener, this);
      this.handlers = [];
      this.runtime.openDataReaderConnection(topic, qos, this);
      this.onclose = function() {};
      this.closed = false;
    }

    DataReader.prototype.addListener = function(l) {
      var idx;
      idx = this.handlers.length;
      this.handlers = this.handlers.concat(l);
      return idx;
    };

    DataReader.prototype.removeListener = function(idx) {
      var h;
      h = this.handlers;
      return this.handlers = h.slice(0, idx).concat(h.slice(idx + 1, h.length));
    };

    DataReader.prototype.onDataAvailable = function(m) {
      var d, s;
      s = m.data;
      d = JSON.parse(s);
      return this.handlers.forEach(function(h) {
        return h(d);
      });
    };

    DataReader.prototype.socketCloseHandler = function(m) {
      this.closed = true;
      return onclose();
    };

    DataReader.prototype.close = function() {
      console.log("Closing DR " + this);
      this.closed = true;
      this.runtime.closeDataReaderConnection(this);
      return onclose();
    };

    DataReader.prototype.isClosed = function() {
      return this.closed;
    };

    return DataReader;

  })();

  DataWriter = (function() {
    function DataWriter(runtime, topic, qos) {
      this.runtime = runtime;
      this.topic = topic;
      this.qos = qos;
      this.socket = dds.None;
      this.runtime.openDataWriterConnection(topic, qos, this);
      this.onclose = function() {};
      this.closed = false;
    }

    DataWriter.prototype.write = function() {
      var ds;
      ds = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return this.socket.map((function(s) {
        var sendData;
        sendData = function(x) {
          var e, xs;
          xs = typeof x === 'string' ? x : JSON.stringify(x);
          try {
            return s.send(xs);
          } catch (_error) {
            e = _error;
            return console.log(e);
          }
        };
        return ds.forEach(sendData);
      }));
    };

    DataWriter.prototype.close = function() {
      console.log("Closing DW " + this);
      this.closed = true;
      this.runtime.closeDataWriterConnection(this);
      return onclose();
    };

    DataWriter.prototype.isClosed = function() {
      return this.closed;
    };

    return DataWriter;

  })();

  DataCache = (function() {
    function DataCache(depth, cache) {
      this.depth = depth;
      this.cache = cache;
      this.fold = __bind(this.fold, this);
      if ((this.cache != null) === false) {
        this.cache = {};
      }
    }

    DataCache.prototype.write = function(k, data) {
      var v;
      v = this.cache[k];
      if ((v != null) === false) {
        v = [data];
      } else {
        v = v.length < this.depth ? v.concat(data) : v.slice(1, v.lenght).concat(data);
      }
      return this.cache[k] = v;
    };

    DataCache.prototype.forEach = function(f) {
      var k, v, _ref, _results;
      _ref = this.cache;
      _results = [];
      for (k in _ref) {
        v = _ref[k];
        _results.push(v.forEach(f));
      }
      return _results;
    };

    DataCache.prototype.map = function(f) {
      var k, result, v, _ref;
      result = {};
      _ref = this.cache;
      for (k in _ref) {
        v = _ref[k];
        result[k] = v.map(f);
      }
      return new DataCache(this.depth, result);
    };

    DataCache.prototype.filter = function(f) {
      var fv, k, result, rv, v, _i, _len, _ref;
      result = {};
      _ref = this.cache;
      for (k in _ref) {
        v = _ref[k];
        for (_i = 0, _len = v.length; _i < _len; _i++) {
          fv = v[_i];
          if (f(v)) {
            rv = fv;
          }
        }
        if (rv.length !== 0) {
          result[k] = rv;
        }
      }
      return result;
    };

    DataCache.prototype.filterNot = function(f) {
      return filter(function(s) {
        return !f(s);
      });
    };

    DataCache.prototype.read = function() {
      var k, result, v, _ref;
      result = [];
      _ref = this.cache;
      for (k in _ref) {
        v = _ref[k];
        result = result.concat(v);
      }
      return result;
    };

    DataCache.prototype.take = function() {
      var k, result, tmpCache, v;
      tmpCache = this.cache;
      this.cache = [];
      result = [];
      for (k in tmpCache) {
        v = tmpCache[k];
        result = result.concat(v);
      }
      return result;
    };

    DataCache.prototype.takeWithFilter = function(f) {
      var e, k, result, rv, tv, v, _i, _j, _len, _len1, _ref;
      result = [];
      _ref = this.cache;
      for (k in _ref) {
        v = _ref[k];
        for (_i = 0, _len = v.length; _i < _len; _i++) {
          e = v[_i];
          if (f(e)) {
            tv = e;
          }
        }
        for (_j = 0, _len1 = v.length; _j < _len1; _j++) {
          e = v[_j];
          if (!f(e)) {
            rv = e;
          }
        }
        result = result.concat(tv);
        this.cache[k] = rv;
      }
      return result;
    };

    DataCache.prototype.get = function(k) {
      var v;
      v = this.cache[k];
      if ((v === void 0)(None)) {

      } else {
        return new Some(v);
      }
    };

    DataCache.prototype.getOrElse = function(k, f) {
      var v;
      v = this.cache[k];
      if ((v === void 0)(f())) {

      } else {
        return new Some(v);
      }
    };

    DataCache.prototype.fold = function(z) {
      var _this = this;
      return function(f) {
        var k, r, v, _ref;
        r = z;
        _ref = _this.cache;
        for (k in _ref) {
          v = _ref[k];
          r = r + v.reduceRight(f);
        }
        return r;
      };
    };

    return DataCache;

  })();

  root.dds.bind = function(key) {
    return function(reader, cache) {
      return reader.addListener(function(d) {
        return cache.write(key(d), d);
      });
    };
  };

  root.dds.Topic = Topic;

  root.dds.DataReader = DataReader;

  root.dds.DataWriter = DataWriter;

  root.dds.DataCache = DataCache;

  root.dds.None = None;

  root.dds.Some = Some;

  root.dds.Success = Success;

  root.dds.Failure = Failure;

  /*
    Protocol
  */


  DSEntityKind = {
    Topic: 0,
    DataReader: 1,
    DataWriter: 2
  };

  DSCommandId = {
    OK: 0,
    Error: 1,
    Create: 2,
    Delegate: 3,
    Unregister: 4
  };

  createHeader = function(c, k, s) {
    var h;
    h = {
      cid: c,
      ek: k,
      sn: s
    };
    return h;
  };

  createTopicInfo = function(domainId, topic, qos) {
    var ti;
    ti = {
      did: domainId,
      tn: topic.tname,
      tt: topic.ttype,
      qos: qos.policies
    };
    return ti;
  };

  createCommand = function(cmdId, kind) {
    return function(seqn, topic, qos) {
      var cmd, tb, th;
      th = createHeader(cmdId, kind, seqn);
      tb = createTopicInfo(topic.did, topic, qos);
      cmd = {
        h: th,
        b: tb
      };
      return cmd;
    };
  };

  root.dds.DSEntityKind = DSEntityKind;

  root.dds.DSCommandId = DSCommandId;

  root.dds.createDataReaderCommand = createCommand(DSCommandId.Create, DSEntityKind.DataReader);

  root.dds.createDataWriterCommand = createCommand(DSCommandId.Create, DSEntityKind.DataWriter);

  /*
    QoS Policies
  */


  PolicyId = {
    History: 0,
    Reliability: 1,
    Partition: 2,
    ContentFilter: 3,
    TimeFilter: 4,
    Durability: 5,
    TransportPriority: 6,
    Ownership: 7,
    OwnershipStrenght: 8
  };

  /*
     History Policy
  */


  HistoryKind = {
    KeepAll: 0,
    KeepLast: 1
  };

  History = {
    KeepAll: {
      id: PolicyId.History,
      k: HistoryKind.KeepAll
    },
    KeepLast: function(depth) {
      var result;
      result = {
        id: PolicyId.History,
        k: HistoryKind.KeepLast,
        v: depth
      };
      return result;
    }
  };

  /*
    Reliability Policy
  */


  ReliabilityKind = {
    Reliable: 0,
    BestEffort: 1
  };

  Reliability = {
    BestEffort: {
      id: PolicyId.Reliability,
      k: ReliabilityKind.BestEffort
    },
    Reliable: {
      id: PolicyId.Reliability,
      k: ReliabilityKind.Reliable
    }
  };

  /*
    Partition Policy
  */


  Partition = function() {
    var p, plist, policy;
    p = arguments[0], plist = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    policy = {
      id: PolicyId.Partition,
      vs: plist.concat(p)
    };
    return policy;
  };

  /*
    Content Filter Policy
  */


  ContentFilter = function(expr) {
    var contentFilter;
    contentFilter = {
      id: PolicyId.ContentFilter,
      v: expr
    };
    return contentFilter;
  };

  /*
    Time Filter Policy
  */


  TimeFilter = function(duration) {
    var timeFilter;
    timeFilter = {
      id: PolicyId.TimeFilter,
      v: duration
    };
    return timeFilter;
  };

  /*
    Durability Policy
  */


  DurabilityKind = {
    Volatile: 0,
    TransientLocal: 1,
    Transient: 2,
    Persistent: 3
  };

  Durability = {
    Volatile: {
      id: DurabilityKind.Volatile
    },
    TransientLocal: {
      id: DurabilityKind.TransientLocal
    },
    Transient: {
      id: DurabilityKind.Transient
    },
    Persistent: {
      id: DurabilityKind.Persistent
    }
  };

  /*
    The Entity QoS is represented as a list of Poilicies.
  */


  EntityQos = (function() {
    function EntityQos() {
      var p, ps;
      p = arguments[0], ps = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      console.log(p);
      console.log(ps);
      this.policies = ps.concat(p);
      console.log(this.policies);
    }

    EntityQos.prototype.add = function() {
      var p;
      p = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return new EntityQos(this.policies.concat(p));
    };

    return EntityQos;

  })();

  /*
    Policy and QoS Exports
  */


  root.dds.HistoryKind = HistoryKind;

  root.dds.History = History;

  root.dds.ReliabilityKind = ReliabilityKind;

  root.dds.Reliability = Reliability;

  root.dds.Partition = Partition;

  root.dds.DurabilityKind = DurabilityKind;

  root.dds.Durability = Durability;

  root.dds.TimeFilter = TimeFilter;

  root.dds.ContentFilter = ContentFilter;

  root.dds.DataReaderQos = EntityQos;

  root.dds.DataWriterQos = EntityQos;

  controllerPath = '/dscript/controller';

  readerPrefixPath = '/dscript/reader';

  writerPrefixPath = '/dscript/writer';

  controllerURL = function(dscriptServer) {
    return dscriptServer + controllerPath;
  };

  readerPrefixURL = function(dscriptServer) {
    return dscriptServer + readerPrefixPath;
  };

  writerPrefixURL = function(dscriptServer) {
    return dscriptServer + writerPrefixPath;
  };

  Runtime = (function() {
    function Runtime(server) {
      this.server = server;
      this.handleMessage = __bind(this.handleMessage, this);
      this.openDataWriterConnection = __bind(this.openDataWriterConnection, this);
      this.closeDataWriterConnection = __bind(this.closeDataWriterConnection, this);
      this.closeDataReaderConnection = __bind(this.closeDataReaderConnection, this);
      this.openDataReaderConnection = __bind(this.openDataReaderConnection, this);
      this.isClosed = __bind(this.isClosed, this);
      this.isConnected = __bind(this.isConnected, this);
      this.close = __bind(this.close, this);
      this.establishDroppedDataConnections = __bind(this.establishDroppedDataConnections, this);
      this.connect = __bind(this.connect, this);
      this.createDataReader = __bind(this.createDataReader, this);
      this.sn = 0;
      this.drmap = {};
      this.dwmap = {};
      this.drconnections = {};
      this.dwconnections = {};
      this.onclose = function(evt) {};
      this.onconnect = function() {};
      this.ondisconnect = function(evt) {};
      this.connected = false;
      this.closed = true;
    }

    Runtime.prototype.createDataReader = function(topic, qos) {
      var dr;
      return dr = new DataReader(this, topic, qos);
    };

    Runtime.prototype.connect = function() {
      var url,
        _this = this;
      console.log("Called connect(): " + this.connected);
      if (this.connected === false) {
        url = controllerURL(this.server);
        console.log("Connecting to: " + url);
        this.ctrlSock = None;
        this.webSocket = new WebSocket(url);
        this.pendingCtrlSock = new Some(this.webSocket);
        this.pendingCtrlSock.map((function(s) {
          return s.onopen = function() {
            console.log('Connected to: ' + _this.server);
            _this.ctrlSock = _this.pendingCtrlSock;
            _this.connected = true;
            console.log("Calling @establishDroppedDataConnections()");
            _this.establishDroppedDataConnections();
            return _this.onconnect();
          };
        }));
        this.pendingCtrlSock.map((function(s) {
          return s.onclose = function(evt) {
            console.log("The  " + _this.server + " seems to have dropped the connection.");
            _this.connected = false;
            _this.closed = false;
            _this.ctrlSock = None;
            return _this.ondisconnect(evt);
          };
        }));
        return this.pendingCtrlSock.map((function(s) {
          return s.onmessage = function(msg) {
            return _this.handleMessage(msg);
          };
        }));
      } else {
        return console.log("Warning: Trying to connect an already connected Runtime");
      }
    };

    Runtime.prototype.establishDroppedDataConnections = function() {
      var k, v, _ref, _ref1, _results;
      console.log("In @establishDroppedDataConnections()");
      _ref = this.drconnections;
      for (k in _ref) {
        v = _ref[k];
        console.log("Establishing dropped connection for data-reader");
        if (v.sock.readyState === v.sock.CLOSED) {
          this.openDataReaderConnection(v.dr.topic, v.dr.qos, v.dr);
        }
      }
      _ref1 = this.dwconnections;
      _results = [];
      for (k in _ref1) {
        v = _ref1[k];
        console.log("Establishing dropped connection for data-writer");
        if (v.sock.readyState === v.sock.CLOSED) {
          _results.push(this.openDataWriterConnection(v.dw.topic, v.dw.qos, v.dw));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Runtime.prototype.close = function() {
      var k, v, _ref, _ref1, _results,
        _this = this;
      this.ctrlSock.map((function(s) {
        s.close();
        return _this.onclose();
      }));
      _ref = this.drconnections;
      for (k in _ref) {
        v = _ref[k];
        v.sock.close();
        v.dr.close();
      }
      _ref1 = this.dwconnections;
      _results = [];
      for (k in _ref1) {
        v = _ref1[k];
        v.sock.close();
        _results.push(v.dw.close());
      }
      return _results;
    };

    Runtime.prototype.isConnected = function() {
      return this.connected;
    };

    Runtime.prototype.isClosed = function() {
      return this.closed;
    };

    Runtime.prototype.openDataReaderConnection = function(topic, qos, dr) {
      var cmd, scmd;
      cmd = dds.createDataReaderCommand(this.sn, topic, qos);
      this.drmap[this.sn] = dr;
      this.sn = this.sn + 1;
      scmd = JSON.stringify(cmd);
      return this.ctrlSock.map(function(s) {
        return s.send(scmd);
      });
    };

    Runtime.prototype.closeDataReaderConnection = function(dr) {
      var sock;
      sock = this.drconnection[dr];
      if (sock(!void 0)) {
        sock.close();
        return delete this.drconnection[dr];
      }
    };

    Runtime.prototype.closeDataWriterConnection = function(dw) {
      var sock;
      console.log("Called closeDataWriterConnection()");
      sock = this.dwconnections[dw];
      if (sock(!void 0)) {
        sock.close();
        return delete this.dwconnections[dw];
      }
    };

    Runtime.prototype.openDataWriterConnection = function(topic, qos, dw) {
      var cmd, scmd;
      cmd = dds.createDataWriterCommand(this.sn, topic, qos);
      this.dwmap[this.sn] = dw;
      this.sn = this.sn + 1;
      scmd = JSON.stringify(cmd);
      console.log("Creating Data Writer on " + (this.ctrlSock.get()));
      this.ctrlSock.map(function(s) {
        return s.send(scmd);
      });
      return console.log("Command sent: " + cmd);
    };

    Runtime.prototype.handleMessage = function(s) {
      var dr, drc, drsock, dw, dwc, dwsock, eid, msg, url;
      console.log('received' + s.data);
      msg = JSON.parse(s.data);
      if (msg.h.cid === DSCommandId.OK) {
        if (msg.h.ek === DSEntityKind.DataReader) {
          eid = msg.b.eid;
          url = readerPrefixURL(this.server) + '/' + eid;
          dr = this.drmap[msg.h.sn];
          drsock = new WebSocket(url);
          drsock.onmessage = dr.onDataAvailable;
          drsock.onclose = dr.onclose();
          delete this.drmap[msg.h.sn];
          drc = {
            dr: dr,
            sock: drsock
          };
          this.drconnections[dr] = drc;
        } else if (msg.h.ek === DSEntityKind.DataWriter) {
          eid = msg.b.eid;
          url = writerPrefixURL(this.server) + '/' + eid;
          dw = this.dwmap[msg.h.sn];
          dwsock = new WebSocket(url);
          dwsock.onclose = function(evt) {
            dw.socket = new dds.Failure(evt);
            return dw.onclose();
          };
          dw.socket = new dds.Success(dwsock);
          delete this.dwmap[msg.h.sn];
          dwc = {
            dw: dw,
            sock: dwsock
          };
          this.dwconnections[dw] = dwc;
        }
      }
      if (msg.h.cid === DSCommandId.Error) {
        throw msg.b.msg;
      }
    };

    return Runtime;

  })();

  root.dds.Runtime = Runtime;

}).call(this);
